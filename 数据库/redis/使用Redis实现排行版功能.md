排行榜功能是一个很普遍的需求。使用 Redis 中有序集合的特性来实现排行榜是又好又快的选择。
一般排行榜都是有实效性的，比如“用户积分榜”。如果没有实效性一直按照总榜来排，可能榜首总是几个老用户，对于新用户来说，那真是太令人沮丧了。
首先，来个“今日积分榜”吧，排序规则是今日用户新增积分从多到少。
那么用户增加积分时，都操作一下记录当天积分增加的有序集合。
假设今天是 2015 年 04 月 01 日，UID 为 1 的用户因为某个操作，增加了 5 个积分。
Redis 命令如下：
```
ZINCRBY rank:20150401 5 1
```
假设还有其他几个用户也增加了积分：
```
ZINCRBY rank:20150401 1 2
ZINCRBY rank:20150401 10 3
```
看看现在有序集合 rank:20150401 中的数据（withscores 参数可以附带获取元素的 score）
```
ZRANGE rank:20150401 0 -1 withscores
```
```
1) "2"
2) "1"
3) "1"
4) "5"
5) "3"
6) "10"
```
因为只有三个元素，所以就查询出了这些数据。

如果每天记录当天的积分排行榜，那么其他花样百出的榜单也就简单了。
比如“昨日积分榜”：
```
ZREVRANGE rank:20150331 0 9 withscores
```
利用并集实现多天的积分总和，实现“上周积分榜”：
```
ZUNIONSTORE rank:last_week 7 rank:20150323 rank:20150324 rank:20150325 rank:20150326 rank:20150327 rank:20150328 rank:20150329 WEIGHTS 1 1 1 1 1 1 1
```
这样就将 7 天的积分记录合并到有序集合 rank:last_week 中了。权重因子 WEIGHTS 如果不给，默认就是 1。为了不隐藏细节，特意写出。
那么查询上周积分榜 Top10 的信息就是：
```
ZREVRANGE rank:last_week  0 9 withscores
```
“月度榜”、“季度榜”、“年度榜”等等就以此类推。