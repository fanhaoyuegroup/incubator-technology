##表

###索引组织表

如果在创建表时没有显示地定义主键，那么InnoDB存储疫情会按照如下方式选择或者创建主键。

* 首先表中是否有非空的唯一索引，如果有，则该列即为主键
* 不符合上述条件，InnoDB存储引擎将自动创建一个6个字节大小的指针

###InnoDB逻辑存储结构

InnoDB存储引擎的所有数据都被逻辑地存放在表空间中。表空间又由段（segment）、区（extent）、页（page）组成。

#### 表空间

默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有数据都放在这个表空间内。如果我们启用了参数innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。

对于启用了innodb_file_per_table参数选项，每张表的表空间内存放的只是数据、索引和插入缓冲，其他类的数据，如撤销（Undo）信息、系统事务信息、二次写缓冲等还是存放在原来的共享表空间内。

####段

表空间是由各个段组成，常见的段有数据段、索引段、回滚段等。在Innodb中，对段的管理都是由引擎自身所完成对的。

####区

区是由64个连续的页组成，即每个区的大小为1MB。对于大的数据段，InnoDB存储引擎最多每次可以申请4个区，以此来保证数据的顺序性能。

####页

页是InnoDB磁盘管理的最小单位。默认情况下，页的大小为16KB。

####行

 InnoDB存储引擎是面向行的，也就是说数据的存放按行进行存放。每个页存放的行记录也是有硬性定义的，最多允许存放16KB/2~200行的记录，即7992行记录。

###InnoDB行记录格式
InnoDB存储引擎记录是以行的形式存储的，也就意味着页中保存着表中一行行的数据。

####Compact行记录格式

Compact行设计目标是能高效存放数据。即如果一个页中存放的行数据越多，其性能就越高。

Compact行记录存储方式：

| 变长字段长度列表       | NULL标志位           | 记录头信息  | 列数据 |
| ------------- |:-------------:| -----:| -----:|

Compact行格式的首部是一个非NULL变长字段长度列表，而且是按照列的顺序逆置放置的。当列的长度小于255字节，用1字节表示，若大于255个字节，用2个字节表示，变长字段的长度最大不可以超过2个字节。变长字段之后的第二个部分是NULL标志位，该位指示了该行数据中是否有NULL值，用1表示。该部分所占的字节应该为1字节。记录头信息，固定占用5个字节。最后的部分就是实际存储的每个列的数据，需要特别注意的是，NULL值不占该部分任何数据，即NULL除了占有NULL标志位，还有两个隐藏列，事务ID列和回滚指针列，分别为6个字节和7个字节的大小。若InnoDB没有定义Primary Key，每行会增加一个6字节的rowId列。


####行溢出数据

大多数的情况，BLOB的行数据还是会发生行溢出，实际数据保存在BLOB页中，数据页只保存数据的前768个字节

####char的行结构存储

一般VARCHAE是存储变长长度的字符类型，CHAE是存储固定长度的字符类型。对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型。这也就意味着在变长长度列表中会记录CHAR数据类型的长度。

###InnoDB数据页结构

InnoDB数据页由以下七个部分组成：

* File Header	
* Page Header	
* Infimum和Supremum Records	
* User Records	
* Free Space	
* Page Directory	
* File Trailer

####File Header

File Header用来记录页的一些头信息，由以下8个部分组成
>
FILE_PAGE_SPACE_OR_CHKSUM，该值代表页的checksum值。
FIL_PAGE_OFFSET：表空间中页的偏移值。
FIL_PAGE_PREV，FIL_PAGE_NEXT：当前页的上一个页以及下一个页。B+ Tree特性据定了叶子节点必须是双向列表。
FIL_PAGE_LSN：该值代表该页最后被修改的日志序列位置LSN（Log Sequence Nuber）。
FIL_PAGE_TYPE：页的类型，通常有：B+树页节点，Undo Log页，索引节点，Insert Buffer空闲列表，该页为最新分配，Insert Buffer位图这几种意思。
FIL_PAGE_FILE_FLUSH_LSG：该值仅在数据文件中的一个页中定义，代表文件至少被更新到了该LSN值。
FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID：该值代表页面属于哪个表空间。

####Page Header
用来记录数据页的状态信息，由14个部分组成
>
PAGE_N_DIR_SLOTS：在Page Directory（页目录）中的Slot（槽）数。
PAGE_HEAP_TOP：堆中第一个记录的指针。
PAGE_N_HEAP：堆中的记录数。
PAGE_FREE：指向空闲列表的首指针。
PAGE_GARBAGE：已删除记录的字节数，即行记录结构中，delete flag为1的记录大小的总数。
PAGE_LAST_INSERT：最后插入记录的位置。
PAGE_DIRECTION：最后插入的方向。
PAGE_N_DIRECTION：宇哥方向连续插入记录的数量。
PAGE_N_RECS：该页中记录的数量。
PAGE_MAX_TRX_ID：修改当前页的最大事务ID，注意该值仅在Secondary Index定义。
PAGE_LEVEL：当前页在索引树中的位置，0x00代表叶节点。
PAGE_IDNEX_ID：当前页属于哪个索引ID。
PAGE_BTR_SEG_LEAF：B+树的叶节点中，文件段的首指针位置。注意该值仅在B+树的Root页中定义。
PAGE_BTR_SEG_TOP：B+树的非叶节点中，文件段的首指针位置。注意该值仅在B+树的Root页中定义。

####Infimum和Supremum记录

在InnoDB存储引擎中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。Supremum和Infimum分别是主键值得上界和下界，这两个值在页创建时被建立，并且在任何情况下不会被删除。

####User Records与FreeSpace

* User Records是实际存储行记录的内容。 
* Free Space指的就是空闲空间，同样也是个链表数据结构。当一条记录被删除后，该空间会被加入空闲链表中。

####Page Directory

Page Directory（页目录）中存放了记录的相对位置。需要注意的是，B+树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页。数据库把页载入内存，然后通过Page Directory再进行二分查找。

####File Trailer

用来检测页是否已经完整地写入磁盘，以此来保证页的完整性。

###约束

关系数据库本身能保证存储数据的完整性，不需要应用程序的控制。几乎所有的关系型数据库都提供了约束机制，就是用来保证数据库中数据的完整性。

###视图

视图是一个命名的虚表，由一个SQL查询来定义，可以当做表使用，但它里面的数据没有实际的物理存储。主要用途之一是被用作一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表的结构，只需要按照视图定义来获取数据或者更新数据。因此，视图同时在一定程度上起到一个安全层的作用。

Mysql本身不支持物化视图。

###分区

Mysql分区实际上就是将一张表的数据分成多个部分，如果对于大的数据量，分区让我们可以快速定位数据位于那一部分，那么就直接排除掉了其他部分的数据，所以分区有利于查询性能。查询未添加索引的列，分区比未分区的表快很多倍；查询已添加索引的列，分区稍由于未分区的表。
MySQL支持以下集中供暖类型分区：
* RANGE分区
* LIST分区
* HASH分区
* KEY分区

子分区是在分区的基础上再进行分区，有时也称这种分区为复合分区。MySQL 数据库允许在RANGE和LIST的分区上进行HASH或KEY的子分区。



