# canal源码分析 (一) 项目结构
## 前言
###   本系列都是基于截止目前最新的canal 1.1.3-alpha-2版本,写本文的目的在于最近几个月一直在公司内构建和受用canal以及otter，之前用的都是基于canal的1.0.26版本的，最近看到canal团队发布了1.1.1的重大升级版本，所以正好借此机会研究一下新版本的特性同时对这段时间所学做一个积累和记录。
## 背景概述
### 关于canal是什么，在项目的github上面已经有过官方的解释了，我也就不再赘述了，直接贴一下地址，供还不了解canal的读者自己先看一下[canal的官方wiki](https://github.com/alibaba/canal/wiki)

## 环境准备
### 大家可以先从官方的github中fork出canal的源码到自己的仓库(为什么要fork？方便自己在源码中做一些自己独有的注释，方便记录)。现在提供一下 [官方github](https://github.com/alibaba/canal) 本文在编写时，官方的最新版本更新到了1.1.3-alpha-2，所以本文都会基于这个版本
## 项目结构
### 现在进入本文重点要将的canal项目的项目结构概述。准备先大概浏览一下canal这个项目的综述
# TODO 代码截图
### 可以看出整个项目费非常多的模块，一开始可能会感觉无从下手，但是不慌，我们慢慢来，一个个模块分别来看一下

#### canal.server && canal.client
 ------------------------------------------

##### 这两个组件属于同一个功能的两段，canal.server负责作为canal服务端提供数据供客户端来调用获取，相应的client就是作为客户端来发送请求。可以理解为一个典型的生产者和消费者的关系，对应的生产出的数据会放入一个内部的RingBuffer中(这个数据结构会在后面提到)。目前server和client提供的模式有三种: 
	- tcp 也就是传统的模式
	- rocketmq
	- kafka
####这边进行一下说明，第一种情况下会启动CanalServerWithNetty这个服务类，启动netty为连接的服务器
####第2.3中情况的话，都会启动CanalMQProducer接口对应实现的子类，客户端也都是从相应的通道来获取数据
####这部分的代码都是由canal启动器中根据xml属性或者像otter实现的在控制台上控制，从数据库获取。分别实例化对应的实现类
### canal.prometheus
#### 再看一下这个模块，从名字也可以很容易看出来，这个是canal结合普罗米修斯组件进行数据可视化监控的模块，默认的暴露的metrics的端口是11112，这个在之后也会提到

### canal.instance
 ------------------------------------------

#### 这个模块主要是作为每一个canal实例从对应的数据库地址获取数据的运行容器。在canal中，每个独立的数据库配置称为一个destination，这个概念也会在源码中反复出现。在canal启动时会将每个canal.instance放在一个map中，并在需要的时候用CanalInstanceGenerator这种生成器生成我们需要的canalInstance。这里提一句，生成器也是在canal启动的时候根据我们的配置来选择具体实现方式。目前源码中提供了两种生成器的模式
	- manager
	- spring
#### 目前默认的是spring的模式，也就是如何生成具体的canal.instance的构造器方式。

### canal.sink && canal.parse && canal.store
 ------------------------------------------

#### 这几个都是之后会重点解释的模块，这几个模块组成了从mysql里得到的binlog文件的记录，怎么被内部解析和组装成为了可供读取的java内的数据结构，之后再存储在相应的介质中。这个介质可以是内存中的，也可以是rocketmq，kafka之类的消息中间中。

### canal.example
 ------------------------------------------
#### 官方提供了一些简单的例子，可以看一下具体的实现方法。

## 以上就是对canal整个代码结构进行了一些简单的解析，有一些组件我还没有提到，在之后的源码探究过程中也会有涉及。好了，现在让我们一起进入这个神秘的中间件里一探究竟。
