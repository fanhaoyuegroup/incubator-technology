#### 你们项目中是如何保证数据一致性的？

删缓存还是更新缓存？为什么要删缓存，原因是删缓存的性能较好？

分布式锁 + 删缓存 + 更新 DB(失败补偿)

#### 代码在执行 SQL 语句时，数据库连接出现了超时异常，但是你不知道这条 SQL 语句在数据库中究竟有没有执行成功，这种情况怎么保证数据的一致性？

事务

#### 你们系统中分布式锁是如何实现的？

```java
SET resource_name my_random_value NX PX 30000
```

延伸 MySQL 与 zk 实现方案

- MySQL：插入唯一索引数据
- zk：临时有序节点，为什么不用永久节点，惊群效应

#### 上面使用 Redis 实现分布式锁会存在什么问题？

删除锁非原子性，需要用 lua 脚本保证原子性。

不加随机值，可能会删除别人的锁。例如 A 加锁并设置超时时间，A 阻塞，超时时间过期，锁删除，B 获取到锁并加锁成功，A 醒来，可能会删除 B 加的锁。

Redis 单机不能保证高可用，Redlock 也不能保证完全高可用，Redlock 的加锁过程，节点挂了重新醒来，时钟跳跃，GC 停顿问题。

#### 项目中除了使用 redis 实现分布式锁，还有哪些使用场景？

缓存？

#### redis 的数据持久化机制？如何保证数据不丢失？当 redis 内存满了以后，内存的淘汰策略？

 - RDB：可以通过命令手动持久化 `save bgsave`，配置触发持久化，X 时间内发生 N 次更新
 - AOF：记录写命令

并不能保证数据完全不丢失。

RDB 如果在服务器宕机前，没有将最新的写命令数据持久化，会导致数据丢失。


AOF 持久化分为三步骤：
 1. 命令追加：记录到 aof_buf 缓冲区
 2. 文件写入：将 aof_buf 缓存区中的数据缓存到操作系统内存缓存区
 3. 文件同步：将操作系统缓冲区的数据持久化到磁盘

AOF 通过事件循环调用 flushAppendOnlyFile 函数进行持久化，flushAppendOnlyFile 的行为由 appendfsync 参数控制，默认为 everysec。

 - always：将 aof_buf 缓冲区的所有内容写入并同步到 AOF 文件
 - everysec：将 aof_buf 缓冲区的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间超过 1s，则对 AOF 文件进行同步
 - no：将 aof_buf 缓存中的内容写到 AOF 文件，何时同步由操作系统决定

所以，aof 在最安全的情况下也可能丢失一个事件循环内的数据。

内存满了：

 - 报错
 - 针对所有键值对使用 LRU 策略进行淘汰
 - 针对设置了过期时间的键值对使用 LRU 策略进行淘汰
 - 针对所有键值对随机淘汰
 - 针对设置了过期时间的键值对随机淘汰

#### AQS 实现锁的原理？与 synchronize 的区别

AQS 通过 volatile 与 CAS 实现。

以 ReentrantLock 为例：

获取锁时先判断是否已经有线程获取到锁，没有则自己获取锁，并设置当前线程拥有锁(重入用)，也有可能当前线程已经获取到锁，这次是重入获取，也获取锁成功。如果其他线程获取到锁，则自己获取失败。

获取失败后会将当前线程包装成 Node 节点加入到队列中，入队后判断当前节点的前置节点是否是头结点，如果是头结点则尝试获取锁，获取锁成功结束自旋，这也是自旋的结束条件。

如果前置节点非头结点或者头结点获取锁失败，则更新自己的节点状态为 SIGNAL，下一次自旋后阻塞，等待唤醒。

获取锁的线程释放锁后或唤醒头结点的 next 节点(因为头结点没有线程信息)，然后这个节点醒来后发现自己的前置节点是头结点，于是尝试获取锁，获取锁成功后，将自己设置为头结点，并清空线程等信息，跳出自旋。也有可能获取锁失败，获取锁失败继续阻塞，等待获取锁的线程释放锁后重新唤醒自己，再尝试获取锁。

synchronized：

Mark Word 标记：

偏向锁：01，无锁也是 01，他们之间通过是否持有偏向锁标记进行区分
轻量级锁：00
重量级锁：10

 - 偏向锁：一个线程多次访问同一个同步代码块(反复获取同一个锁)，不存在竞争
    1. 检查 mark word 的线程 id
    2. 如果为空则设置 CAS 替换当前线程 id。如果替换成功则获取锁成功
    3. 如果不为空则检查线程 id 为是否为本线程。如果是则获取锁成功
 - 轻量级锁：在偏向锁的前提下，如果被另外的线程访问，偏向锁会升级为轻量级锁，其他线程会以自旋的形式进行重试，不会阻塞，从而提升性能
 - 重量级锁：在轻量级锁前提下，如果重试超过了一定次数或者又有其他线程访问同步代码块，轻量级锁会升级为重量级锁，此时等待线程会被阻塞

简单的来说偏向锁通过对比 Mark Word thread id 解决加锁问题。而轻量级锁是通过用 CAS 操作 Mark Word 和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

#### MySQL 存储引擎的区别？数据库有哪些隔离级别？

InnoDB：

 - 支持事务，行锁，外键
 - 索引结构不一样，聚簇索引，二级索引，聚簇索引即数据

MyIsam：

 - 不支持事务，不支持行锁，不支持外键
 - 完整数据保存在一个文件，不是树结构，有行号概念，索引里保存了数据的 ID 和行号，根据行号查找完整数据

隔离级别：

 - RUC：all 问题
 - RC：解决脏读
 - RR：解决脏读、不可重复度和幻读
 - SE：解决所有问题

#### MySQL 索引的数据结构是什么？为什么选择这种数据结构？

B+ 树，B+ 树只有叶子节点保存完整数据，树的层级低，查找 IO 次数少。

为什么不用哈希索引：哈希索引范围查询困难

#### Reactor 线程模型有哪些？Netty 是如何支持这三种线程模型的？

 - 单线程模型：所有的 I/O 操作都在同一个 NIO 线程上面完成
 - 多线程模型：一组 NIO 线程来处理连接读写操作
 - 主从多线程模型：服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池

[Netty 系列之 Netty 线程模型](https://www.infoq.cn/article/netty-threading-model)

#### 多路复用器的实现原理？

[深入剖析Java NIO之Selector（多路复用器）](https://blog.csdn.net/u014730165/article/details/85089085)

#### epoll 的实现原理？epoll、poll、select 的区别

 - select：单个进程管理的 fd 有限，线性扫描 socket，即采用轮询的方法，效率较低
 - poll：使用链表实现，没有 fd 个数限制，线性扫描 socket，即采用轮询的方法，效率较低
 - epoll：fd 不受限制，不以遍历的形式查找准备好的 fd，而是 fd 准备好以 callback 的形式进行通知

#### JVM 如何进行垃圾回收？标记算法有哪些？垃圾回收算法有哪些？

GC root 引用链

 - 标记-清除：老年代，内存碎片大，大对象分配不友好，导致 Full GC
 - 复制：新生代，Eden 区 与 Survivor 区
 - 标记整理：老年代，清除垃圾后将存活的对象向一侧移动

GC 算法：

 - Serial：单线程
 - Parnew：多线程
 - 吞吐量：
 - SMS：低停顿
 - G1：

#### CMS 垃圾回收器的原理？

老年代-标记清除算法。

 1. 初始标记：STW
 2. 并发标记：耗时，并发
 3. 重新标记：STW
 4. 并发清除：耗时，并发

低停顿，耗时的并发标记与并发清除阶段可以与用户线程共存。

问题：

 - 无法处理浮动垃圾
 - CPU 资源敏感
 - 内存碎片

#### ThreadLocal 的实现原理？

线程有 threadLocals 对象，是个 ThreadLocalMap(Entry 结构)，key 是 ThreadLocalMap 对象。因为数据都在每个线程里，因此多线程之间可以实现数据隔离。

线性探测法解决哈希冲突，内存泄漏，rehash。

key 是弱引用，为什么不把 Entry 设计为弱引用？如果 Entry 被设计成弱引用，被 GC 回收后，当出现哈希冲突时找不到临界条件。

因为 key 是弱引用，因此很多方法里都会对 Entry != null and key == null 的数据进行处理。与 IdentityHashMap 类似。

子线程如果想要获取父进程 ThreadLocal 里的数据应该怎么做？
答：InheritableThreadLocal，原理是 Thread 的构造函数里有一个 init 方法，这个方法会将父线程的 inheritableThreadLocals 参数传递给子线程。

#### MySQL 是如何解决不可重复读问题的？

MySQL 的隔离级别默认是 Repeatable Read 可以解决脏读、不可重复读和幻读问题。利用 RR 级别的 MVCC(多版本并发控制)避免不可重复读和幻读问题。

#### MVCC 的实现原理

MySQL 数据默认有三个隐藏列 row_id，trx_id，roll_pointer，如果有主键，则默认两个隐藏列 trx_id 和 roll_pointer。

为了保障事务的原子性和隔离性，MySQL 提供了 undo_log 来记录在事务执行过程中的变化情况。roll_pointer 指针将一条数据变更的 undo_log 构建成一个链表形式的数据结构，其中包含事务执行前的真实记录和事务执行过程中的变更记录。

在事务执行过程中，读会生成 ReadView，这个 ReadView 有以下几个属性：

 - m_ids ：活跃的事务 ID 集合
 - min_trx_id ：m_ids 最小的值
 - max_trx_id：分配给下一个事务的 id 值，并不是 m_ids 中的最大值
 - creator_trx_id ：创建当前 ReadView 的事务 ID

事务访问逻辑如下：

 - 如果访问数据的事务 ID 小于 min_trx_id，该版本数据可以被访问
 - 如果访问数据的事务 ID 等于 creator_trx_id，该版本数据可以被访问
 - 如果访问数据的事务 ID 大于或等于 max_trx_id，该版本数据不可以被访问
 - 如果访问数据的事务 ID 在 min_trx_id 和 max_trx_id 之间，如果被访问数据的事务 ID 不在 m_ids 集合中，可以被访问，如果在则不可以被访问

RR 级别的事务在执行过程中只会生成一个 ReadView，意味着后续执行相同的查询仍然会用之前生成的 ReadView，而 RC 级别每次读之前都会生成一个 ReadView，这也是为什么 RR 可以解决不可重复读问题的关键。

#### MySQL 的可重复读隔离级别下，存在幻读吗？为什么？

我认为 MySQL RR 隔离级别下是可以解决幻读问题的，因为幻读的定义是只针对查询时查到了之前没有读到的新增的数据。RR 隔离级别下，由于有 MCVV 的控制，不会读到别的事务已提交的数据。

但是 MySQL RR 隔离级别下仍然有一个问题：假设存在两个事务，事务 A 进行了范围查询，查到符合条件的数据有两条，事务 B 对数据进行修改，把一条不符合条件的数据改成了符合条件，然后提交事务 B，之后事务 A 再用之前的范围查询条件进行查询，会查到事务 B 修改过的那条数据。

幻读问题是指针对新增的数据，由于上面的问题是由于更新数据导致的，个人觉得是不属于幻读范畴。

#### 数据库的索引是不是创建得越多越好？为什么？通常创建几个？

不是，每个索引都是一个 B+ 树数据结构，都会占用磁盘空间，索引越多肯定占用的空间也越多，另外一个问题是，查询语句在执行前会通过执行器优化选择成本最小的索引执行查询，索引多了，优化时间相对会变长。

创建几个？最好是索引覆盖。

#### 一张表中对 a、b、c 三个字段分别建立了索引，现在有一条 SQL 语句：select field1,field2 ... from t where a = xx and b=xx and c=xx. 请问这条 SQL 语句会使用到索引吗？如果会，那么会使用到哪个索引？(回答：只会使用其中一个索引，可能是 a,也可能是 b，还有可能是 c，具体使用哪个索引和表中的数据有关)

哪个索引都可能会用到(只用一个索引)，也可能会用到多个索引。

 - 只用一个索引：MySQL 的优化器会对成本进行计算，使用成本最小的那个索引进行查询，比如利用 a，使用索引 a 对数据进行查找，查找到的结果再回表查询，回表后再用 b 和 c 字段进行过滤
 - 用到多个索引：用多个索引(两个或者三个)，可能会出现 index merge，原因是使用一个索引查询，查到的数据量过多，回表可能是随机 IO，导致性能下降，index merge 表示使用多个索引，将多个索引查找的数据结果合并，这样回表的数据量会大大减少

#### 为什么不会同时使用 a,b,c 三个索引？什么是回表？

可能会同时使用三个索引(索引合并)。

回表是指使用二级索引查询，并且查询的字段除了索引字段外还有非索引字段，这种查询在使用二级索引查询后需要拿到符合条件的数据 ID 再到聚簇索引上查询。

如果查询的字段只有索引字段，是不需要回表的，这种查询级别是 index。

#### 聚簇索引和非聚簇索引的区别

聚簇索引包含表数据所有字段信息，非聚簇索引(二级索引)只包含索引列和主键 ID 列。

#### 如何知道一条 SQL 语句使用了哪些索引？

可以使用 explain 关键字对查询语句进行分析

#### explain 的结果有哪些列？分别代表什么含义？

 - const：数据唯一，比如主键 ID 和唯一索引作为条件
 - ref：正常的使用索引的查询
 - range：使用索引的范围查询
 - index：二级索引查询的字段只有索引字段
 - all：不适用索引，全表扫描

#### 如何查看慢 SQL？

MySQL 可以开启 slow_query_log，并设置慢查询的记录位置和慢查询时间阈值。

一般情况下会有第三方的监控工具提供可视化的界面。

#### 在 Spring 事务中执行多条 SQL 语句时，是对应多个数据库连接还是一个数据库连接？

一个连接，多个就无法保证事务了

#### 既然是一个连接，Spring 在前后执行多条 SQL 时，是如何保证当前线程获取到同一个连接的？

ThreadLocal，ThreadLocal 原理见上。

#### Redis 主从复制的原理

 1. 主从连接后，从向主发送 PSYNC 命令
 2. 主收到 PSYNC 命令后，执行 BGSAVE 生成 RDB，发送给从
 3. 从收到 RDB 载入数据
 4. 主将缓冲区的数据再发给从
 5. 同步完成后，主每收到写命令，都会同步给从

#### MQ 使用过哪些？如何选型？

#### 使用的是什么 RPC 框架？为什么选择它？


#### 线上服务流量猛涨，该如何操作，说下详细过程？新加服务节点也可能会导致服务还没起来，机器就被打爆了，这个时候怎么办？

先看是否有限流功能，如果有可以先考虑对某些不影响链路的接口进行流控，或者对相对耗时且不影响链路的接口进行降级。

？？？

#### 一个场景题：现在有 1000 万的商家，知道他们的地理位置，当我们进入到 APP 首页时，如何加载出附近的商家？

利用 Redis 的 Geo 数据结构进行计算。

[你附近的人都有谁，这个功能是怎么实现的？](https://www.hoohack.me/2020/09/19/using-redis-geo-find-nearby)

#### Java 中的锁有哪些？和 Lock 的区别

ReentrantLock、ReentrantReadWriteLock

和 Lock 有什么区别？接口实现类？

#### volatile 的作用和实现原理？

volatile 可以保证内存可见性，防指指令重排序。

volatile 修饰的字段可以使缓存行失效，每次读数据都从内存中读最新值。volatile 通过内存屏障防止重排序问题。

#### GC Roots 有哪些？

 - 栈中引用的对象
 - 本地方法栈中 JNI（即一般说的Native方法）中引用的对象
 - 方法区中类静态属性引用的对象
 - 方法区中常量引用的对象

#### 简述新生代与老年代的区别？

新生代与老年代都在 Java 堆中，新生代分为 Eden 与 两个 survivor 区。

对象优先在新生代分配内存，当新生代内存不够时，会触发 Young GC。老年代内存不够时触发 Full GC。

大对象优先在老年代分配内存，或者对象在新生代经历多次(默认 15) Young GC 仍然没有被回收，会转移到老年去。

#### 类的加载过程？什么是双亲委派机制？

 1. 加载：将 class 文件从各个来源通过类加载器加载进内存
 2. 验证：校验 class 文件格式
 3. 准备：为类变量分配内存，并初始化默认值
 4. 解析：将符号引用转换为直接引用，把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用
 5. 初始化：初始化，为类的静态变量赋予正确的初始值并进行初始化
 6. 使用：
 7. 卸载：

双亲委派机制是指一个类加载器当接收到加载类的请求后，自己不会立即尝试加载，而是判断有没有父加载器，如果存在父加载器，则让父加载器加载。双亲委派机制的目的是防止多个类加载器加载同一个类，而导致程序出错。

#### 线程池的实现原理？线程池满了，再提交任务时会怎么处理？

当线程池内核心线程数没有达到最大值时，创建核心线程执行任务，任务执行完成后从自旋从阻塞队列获取任务，如果核心线程可回收，在核心线程默认的存活时间内没有从队列中获取到任务，核心线程会被回收，默认核心线程是不会被回收的，因此会一直在队列中阻塞。

线程池满了会将任务加入阻塞队列，如果是有界队列，会入队失败，入队失败创建非核心线程执行任务，非核心线程创建失败，执行拒绝策略。

#### 线程池内的线程什么时候会创建非核心线程

主要有以下两个场景：

 - 阻塞队列已满，再向线程池内添加任务，会创建非核心线程
 - 线程池内的线程被回收，为了防止阻塞队列中有任务没有执行，需要创建一个没有任务的非核心线程，类似一个补偿机制

#### 线程池内的线程什么时候回收

PS：线程池内的核心线程也是可以回收的，默认情况下不允许回收，可以通过重写 allowCoreThreadTimeOut(boolean value) 方法进行配置。

 - 正常退出：
    - allowCoreThreadTimeOut 被标记为 true，核心线程在 keepAliveTime 时间范围内没有从队列中获取到任务，核心线程回收，allowCoreThreadTimeOut 默认为 false
    - 线程池内的线程数大于核心线程数，意味着存在非核心线程，如果有线程在 keepAliveTime 时间范围内没有从队列中获取到任务，非核心线程回收
 - 异常退出：
    - 创建 Worker时出现异常，Worker 线程没有跑起来，这时会回收线程

#### Worker 为什么实现AQS

Worker 在执行任务前后会加锁和释放锁。

在 shutdown 线程池时，会向所有空闲的线程发送一个中断信号，shutdown 方法在中断线程之前会调用 Worker 的 tryLock 方法，如果成功会中断线程。

加锁成功就说明这个 Worker 的工作线程是空闲的。加锁失败说明这个工作线程在忙，此时还不能中断它，那这个线程在忙什么呢？答案在 runWorker 方法中，当工作线程获取到任务，执行任务之前会 w.lock()，任务执行完会释放锁。

#### 什么是缓存击穿、缓存穿透、缓存雪崩？如何处理？

 - 缓存雪崩：缓存集中在某一时刻大面积失效，所有请求到 DB
    - 根据业务场景判断是否可以添加一定随机值
    - 服务降级
 - 缓存穿透：请求的数据在 Redis 和 DB 中不存在，缓存没有意义
    - 缓存穿透数据，但是缓存时间不宜过长
    - 布隆过滤器
 - 缓存击穿：热点 key 过期，短时间内大量流量请求到 DB
    - 根据业务场景判断，key 过期是否可以终止业务请求
    - 如果不能终止业务请求，通过分布式锁重新将数据缓存

#### MySQL 数据库索引的实现原理？

MySQL 的索引是一个帮助快速查找的数据结构，底层是 B+ 树，聚簇索引的叶子节点包含了全部数据，即索引即数据。

索引的每一层由数据页构成的双向链表组成。

#### 什么是回表？什么是联合索引？什么是最左前缀匹配原则？

回表是指使用二级索引查询，且查询的字段包含非二级索引字段，在二级索引上拿到符合条件的数据 ID，再到聚簇索引上查询全部数据，拿到查询字段数据。

联合索引？多个字段构成的索引

最左匹配原则？

#### MySQL 如何保证高可用？主从复制原理？

为主库添加备库。

主从复制原理：

 - 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量
 - 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接
 - 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B
 - 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）
 - sql_thread 读取中转日志，解析出日志里的命令，并执行

#### RocketMQ 的实现原理


#### 注册中心的选型？

#### Zookeeper 作为注册中心的实现原理？

#### Zookeeper 实现分布式锁的原理？

每次请求进来都在目录下创建一个临时有序节点，如果这个临时有序节点的序号是这个目录里最小的，则获取到锁。返之，对上一个临时有序节点添加监听，当上一个节点拿到锁释放后通知自己。

为什么不用永久节点：永久节点在客户端退出后仍然存在，如果出现异常客户端退出，节点仍然存在可能导致后续的节点一直获取不到锁。

惊群效应？当一个节点释放锁后，只需要通知下一个监听自己的节点，不用通知所有节点。

zk 在 CAP 理论中注重 CP，在 zk 集群挂掉重新选举期间，会有较长时间的服务不可用。

#### redis 缓存和数据库数据一致性怎么解决？

 - 监听 binlog，同步 Redis
 - 通过 MQ 异步更新 Redis，失败重试保持最终一致性

#### 分布式系统中，分布式事务怎么解决？（回答：RocketMQ 的事务消息）


#### RocketMQ 事务消息的实现原理？你们的项目中是如何通过 RocketMQ 来保证数据一致性


#### 什么是覆盖索引？

使用二级索引查询，并且查询的字段在索引列中都能找到，进行条件过滤后，不用回聚簇索引进行二次查询。对应 index 级别的查询

#### SQL 的优化经验？

 - 避免创建多个索引，节省内存
 - 避免 select `*`，避免回表不必要的查询
 - 隐式类型转换：如果数据库的字段类型是字符串，条件参数是数字类型，并不会使用索引
 - 尽量使用聚簇索引，避免回表增加 IO 查询次数

#### Redis key 的过期策略？

常用过期策略：

 - 定时删除：添加定时器，时间到了删除 key，比较耗费内存，对服务器响应时间与吞吐量有影响
 - 惰性删除：每次在获取 key 时判断是否过期，如果有的 key 不查询会一直在内存中，对内存不友好
 - 定期删除：每过一点时间，对数据进行扫描，过期了就删除，是折中的方案

Redis 采用的是惰性删除与定期删除策略结合的方案。定期删除并不会扫描所有的 DB，具体策略由算法决定。

#### RocketMQ 如何保证数据的可靠传输(数据不丢失)？

#### RocketMQ 中现在堆积了大量消息，该怎么处理？

 - 增加消费者机器

[如何处理消息堆积](https://help.aliyun.com/document_detail/193952.html)

#### Netty 的线程模型？主从多线程模型下，线程是如何分工的？


#### 如何设置线程池的参数？

合理设置线程数的目的是榨干 CPU 的运行能力，特别是在多核服务器的场景下。

 - CPU 密集型：CPU 核数 + 1
 - IO 密集型：CPU核心数 * （1 + (I/O耗时/CPU耗时)）

#### 对于 CPU 密集型的系统，为什么线程个数设置为 CPU 核数+1？为什么要+1？

计算密（CPU）集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。

通俗点讲就是补偿，如果有一个线程发生了阻塞，有一个备用的线程仍然能够工作。

#### 对于 IO 密集型的系统，为什么线程个数为 2 倍 CPU 核数？为什么是 2 倍，而不是 3 倍、4 倍等等？

2 倍不准确？？

应该分别计算程序 IO 与 CPU 的耗时，根据比例设置合适的线程数。

#### RPC 框架的选型？


#### Http 和 Https 的区别？

Http 的问题：

 - 明文传输
 - 可以伪造身份
 - 篡改传输信息

Http 通过加密算法对传输信息进行加密，防止出现上面的问题。

 - 对称加密：加密与解密都是用同一个秘钥
 - 非对称加密：使用公钥加密，私钥解密，公钥是公开的，任何人都可以获得

Https 采用对称加密与非对称加密混合加密机制，使用非对称加密交换对称加密过程中使用的秘钥，确保秘钥安全的前提下，使用对称加密的方式进行通信。

非对称加密的公钥在数字证书中，数字证书由可信赖的第三方机构颁布，只要证书是安全的，非对称加密的公钥就是安全的。

客户端向服务端发送请求，服务端返回数字证书，由于客户端的浏览器或操作系统维护了权威认证机构的的名称和公钥，因此可以解析出证书中的公钥，客户端认证通过后，生成对称加密使用的秘钥，将该秘钥用解析出的公钥加密发送给服务器，服务器用自己的私钥解析出对称加密秘钥。后续客户端与服务端使用对称加密秘钥进行数据传输。



#### TCP 的三次握手和四次挥手？

TCP 是全双工通信。

![](https://camo.githubusercontent.com/e65b3d3cfa324024584e16826db91774edbc6eec3b705164054b69a2fe2dcff8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323031393035303931313036333531322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c324e765a47567159584d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730)

三次握手的目的是初始化序列号，与确认双方数据收发能力。其中第三次握手可以携带数据，因为连接已经建立了，不用担心有攻击。

由于 TCP 全双工通信特点，客户端与服务端需要四次挥手才能关闭连接。

#### TCP 如何保证可靠传输？

感觉比较宽泛？回答一些 TCP 相关的特性

 - 超时重传机制：比如主机 A 向主机 B 发送了报文段，收到数据的主机 B 需要向主机 A 发送 ACK 确认，如果 ACK 在定时器时间内没有到达或者丢失，那么主机 A 会重发上一个报文段
    - 超时间隔加倍：下一次超时时间设置为之前的两倍，这种方案增加了端到端数据传输的时延
    - 快速重传：发送方收到 3 个以上冗余的 ACK，快速重传丢失的报文段
 - 数据校验：首部校验和
 - 流量控制：发送方发送的数据过多、过快，接收方读取数据较慢，导致接收方数据缓存溢出了。TCP 首部有个 window 字段可以用来告知发送方还有多大的缓存空间可用
 - 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。拥塞控制算法：
    - 慢启动
    - 拥塞避免
    - 快速恢复
 - 滑动窗口：

#### BIO、NIO、AIO 的区别？

BIO：同步阻塞模式，线程发起 IO 请求后，如果缓冲区数据没有就绪会一直阻塞
NIO：同步非阻塞模式，线程发起 IO 请求后，可以立即返回，不用阻塞，但是需要定时轮训缓冲区数据是否就绪
AIO：异步非阻塞 IO，线程发起 IO 请求后，缓冲区数据就绪后发送通知

NIO 与 BIO 的选择：如果需要管理成千上万个连接，比如聊天服务器等，可以用 NIO，如果只需要管理很少的连接，且每个连接都需要占用很大的带宽，可以选择 BIO

#### 如何保证接口的安全性？应该使用什么加密策略？

签名验证：app_id、timestamp、sign 等

md5？

#### 说下一致性哈希算法？

一致性哈希算法的目的是让请求均匀地分配到多个服务器，特别是缓存服务器。

普通哈希：对数据进行哈希运算，%N 得到余数，对机器进行编号，将数据保存到对应编号的机器上。普通哈希有一个很严重的缺陷，当增加或者减少机器会导致雪崩，所有机器上的数据均失效不可用。

一致性哈希：

一致性哈希也采样取模的算法，只不过是对 2^32 取模，2^32 构成一个哈希环。可以通过 hash（服务器IP地址） %  2^32 将机器映射到哈希环中。如果有请求过来对请求进行 hash（请求标识） %  2^32  运算获得模，从对象的模位置出发，顺时针方向遇到的第一个服务器，就是接收请求的服务器。

一致性哈希的有点很明显，当新增或者删除一个服务器后，不会导致所有服务器不可用。

一致性哈希也有一个明显的缺点：服务器需要进行哈希运算映射到哈希环上，多个服务器可能偏斜严重，会导致服务器接收请求不均匀。为了解决这个问题可以添加虚拟节点，虚拟节点映射真实节点。

一致性哈希的应用可以参考 Redis 集群，Redis 集群有 16384 个槽，集群中的每个主节点负责处理一部分槽，只有当槽被完全分配集群才可以正常运行。

[白话解析：一致性哈希算法 consistent hashing](https://www.zsythink.net/archives/1182)

#### MySQL 的调优经验

使用 explain 关键字对查询语句进行分析，注意一下索引事项：

 - 索引列类型尽量小
 - 尽量覆盖索引
 - 列基数大创建索引

#### 中台的理解？

分布式微服务业务平台

### MTU 与 MSS

MTU：Maximum Transmit Unit 最大传输单元，即数据链路层提供给上层最大一次传输数据的大小，缺省 MTU = 1500。MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。

MSS：Maximum Segment Size 最大 TCP 分段大小，不含 TCP 头和 option 信息，TCP 用来限制自己每次用来发送数据的最大分段大小。通信双方会在三次握手时确定这次连接的 MSS。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据进行拆分，构成多个数据段。

IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。

TCP 如果没有 MSS 概念会有以下问题：

当 TCP 协议交给 IP 层发送一个 1600 字节（包括 IP 和 TCP 协议头）的数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500 字节，所以 IP 协议会对数据包分成两片。这两个数据包中只有一个数据包包含 TCP 协议头，即控制位、序列号等信息。

当 IP 协议传输数据丢包时，TCP 协议的接收方没有办法对数据包进行重组，所以整个 TCP 数据段都需要重传，带来了更多额外的重传和重组开销。

[为什么 TCP/IP 协议会拆分数据](https://draveness.me/whys-the-design-tcp-segment-ip-packet/#fn:2)

#### RPC(远程过程调用)

协议允许一台机器的程序调用另一地址空间的子程序，就像本地方法调用一样，无需为这个调用进行额外编程。

调用过程：

 1. 客户端调用本地存根
 2. 客户端本地存根将参数封装，由系统调用发送到服务端机器
 3. 客户端本地系统发送信息至服务器
 4. 服务器将信息传送到服务端存根
 5. 服务端存根解析信息，发起程序调用，并以类似的形式返回给客户端

 - 客户端：服务调用方
 - 客户端存根：存放服务端地址等信息，将客户端的请求打包成网络消息，通过网络传输发送给服务端
 - 服务端：服务提供方
 - 服务端存根：接收客户端发送来的消息并进行解析，然后调用本地服务端服务

[远程过程调用](https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8)

